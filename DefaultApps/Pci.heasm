/**
* Pci.heasm
*
* consultador de PCis y su manejo desde la linea de comandos y con varias comodidades
*
* xd creaba aplicaciones para los gringos cuando el codigo esta en español
* jaja
*
*
*


*
* ejecutando la guia de uso de la aplicacion
*


KellyBootloader> ./Pci.ebf --?

=================
| [] [] [] [] [ ]
| Bus PCI Mgr | |
-O-------------O|

This application can help you to find PCi buses
and make anything, all in the Shell, enjoy ^-^

syntax: Pci [Command] [Class?] [Register?] [Data?]

Commands:
  --?: get this guide
  --fch: find a PCI bus and prints the direction
  --wrt: write in the first PCi data
  --red: read the first PCi data
  --lst: get a list of all the PCis with that type
  --ls: list all the PCis without discrimination (posibilitie excepcions in the UEFI included)

Classes:
 Display:
   03: PciClassDisplayCtrl
   00: PciClassVga
 Isa:
   01: PciClassIsa
   80: PciClassIsaPositiveDecode
 Net:
   02: PciClassNetwork
   00: PciClassEthernet
 OnlyInEmulator:
   15: PciHtmlDocMgr
   16: PciHtmlDocPusher

KellyBootloader>


*
* un ejemplo escribiendo y leyendo en un pci de networck (la clase 02)
*


KellyBootloader> ./Pci.ebf --wrt 02 00 10
Status: 0xE

* parece que OVMF no tiene ganas de ser OVMF
* 0xE en mi funcion significa que la funcion de escritura apunta a nullptr asi que lanza EFI_NOT_FOUND

KellyBootloader> ./Pci.ebf --red 02 00
!!!! X64 Exception Type - 06(#UD - Invalid Opcode) RIP - A0000

* 0xE significa EFI_NOT_FOUND por que la funcion de escritura apuntaba a nullptr, asi que para evitar crasheos
* el portal de la funcion de escritura de ErickBinaryFormat para PCis lanzo EFI_NOT_FOUND para evitar una excepcion
*
* y ocurrio una excepcion por que aunque no sea nulo el puntero a la funcion de escritura no lo implementan bien en qemu

*
* un ejemplo listando todos los dispositivos de la clase PciClassNetwork y de la clase PciClassIsaPositiveDecode
*

KellyBootloader> ./Pci.ebf --lst 02
PciIndex: 3
Direction: 000182003


KellyBootloader> ./Pci.ebf --lst 80
PciIndex: 3
Direction: 000182003
** ah? por que son iguales? nahh, cosas de qemu y OVMF

KellyBootloader> map
* ... tengo flojera de escribir el mapa de nuevo ,en resumen hay un buffer del comando --ls suelto, no se por que
* ahorita lo arreglo, seguro al ver esto ya esta arreglado
KellyBootloader> ojos azules
KellyBootloader> hasta la cintura le llega el pelo
KellyBootloader> //?? jaja se ponia a cantar
* aprendi 2 cosas, que la shell de kellybootloader perdona errores de comandos inexistentes y que
* luego a Erick le encanta cantar, a no mames si soy Erick el que escribe esto
* no espera hay niños que usan ErickBinaryFormat y esta aplicacion viendo, no digas eso

*
* un ejemplo listando todos los dispositivos PCi sin discriminacion
*

KellyBootloader> ./Pci.ebf --ls
** perfecto, el sistema se colgo jsjsjs maldito OVMF y qemu

*
* un ejemplo obteniendo el primer pci de pantalla que encuentre
* esto puede varear en los equipos pero este es lo que me muestra
*

KellyBootloader> ./Pci.ebf --fch 03 0

Pci Info:
Type = 03
Direction = 0000001000

KellyBootloader>

*/

// incluir la libreria universal
%include
    lib/ebf.heasm



/**
* _HexDirection_
*
* direccion en hexadecimal por partes
*/
Array _HexDirection_ _YaLeTocaraXd_

/**
* _GuideCommand_
*
* comando de guia
*/
Array _GuideCommand_ AllocatePool->3

/**
* _FindChild_
*
* comando para encontrar buses
*/
Array _FindChild_ AllocatePool->5

/**
* _WritePci_
*
* comando para escribir en buses
*/
Array _WritePci_ AllocatePool->5

/**
* _ReadPci_
*
* comando para leer en buses
*/
Array _ReadPci_ AllocatePool->5

/**
* _ListPciCmd_
*
* comando para listar buses
*/
Array _ListPciCmd_ AllocatePool->5

/**
* _LsPcisCmd_
*
* comando para listar todos los PCi
*/
Array _LsPcisCmd_ AllocatePool->4

/**
* _PciIdsList_
*
* la lista que se usa en ciertos comandos
*/
Array _PciIdsList_ _YaLeTocaraXd_

/**
* _Command_
*
* el comando
*/
Array _Command_ _YaLeTocaraXd_

/**
* _PciDirection_
*
* la direccion completa del PCi
*/
Array _PciDirection_ _YaLeTocaraXd_

/**
* _Index_
*
* el index
*/
LET _Index_

/**
* _PciClassParam_
*
* el parametro de la clase del PCi a obtener
*/
LET _PciClassParam_

/**
* _PciRegister_
*
* el registro del PCi
*/
LET _PciRegister_

/**
* _PciDataWrite_
*
* el dato a escribir
*/
LET _PciDataWrite_

/**
* _Initialize_
*
* funcion de inicializacion
*/
FUNCTION _Initialize_
    _IProto()

/**
* _ReadFirstChild_
*
* lee el dato de lo primero que encuentre
*/
FUNCTION _ReadFirstChild_
    _IProto()

/**
* _WrtieFirstChild_
*
* escribe el dato en el primer pci que encuentre
*/
FUNCTION _WrtieFirstChild_
    _IProto()

/**
* _Main_
*
* funcion del programa principal
*/
FUNCTION _Main_
    _IProto()

/**
* _FindChildAction_
*
* encontrar un pci
*/
FUNCTION _FindChildAction_
    _IProto()

/**
* _Clear_
*
* limpiar las variables
*/
FUNCTION _Clear_
    _IProto()

/**
* _ShowGuide_
*
* muestra la guia
*/
FUNCTION _ShowGuide_
    _IProto()

//
// inicializar las variables
//

_PciClassParam_ = 0
_PciRegister_ = 0

//
// comenzar con la inicializacion
//

call _Initialize_
call _Main_

// limpiar todo
call _Clear_

// detener el programa
_CallOut 0 0

FUNCTION _Initialize_

    // comando de busqueda de buses
    _FindChild_ [0] '-'
    _FindChild_ [1] '-'
    _FindChild_ [2] 'f'
    _FindChild_ [3] 'c'
    _FindChild_ [4] 'h'

    // comando de guia
    _GuideCommand_ [0] '-'
    _GuideCommand_ [1] '-'
    _GuideCommand_ [2] '?'

    // comando de escritura
    _WritePci_ [0] '-'
    _WritePci_ [1] '-'
    _WritePci_ [2] 'w'
    _WritePci_ [3] 'r'
    _WritePci_ [4] 't'

    // comando de lectura
    _ReadPci_ [0] '-'
    _ReadPci_ [1] '-'
    _ReadPci_ [2] 'r'
    _ReadPci_ [3] 'e'
    _ReadPci_ [4] 'd'

    // comando de listado
    _ListPciCmd_ [0] '-'
    _ListPciCmd_ [1] '-'
    _ListPciCmd_ [2] 'l'
    _ListPciCmd_ [3] 's'
    _ListPciCmd_ [4] 't'

    // comando de listado sin filtro
    _LsPcisCmd_ [0] '-'
    _LsPcisCmd_ [1] '-'
    _LsPcisCmd_ [2] 'l'
    _LsPcisCmd_ [3] 's'

    // obtener el comando
    call_tapot GetParam 0 _Command_

    // obtener la clase a obtener
    call_tapot GetParam 1 5
    call_tapot Xtoi 5 _PciClassParam_
    
    // obtener el parametro del registro
    call_tapot GetParam 2 5
    call_tapot Xtoi 5 _PciRegister_
    
    // obtener el parametro del dato
    call_tapot GetParam 3 5
    call_tapot Xtoi 5 _PciDataWrite_

    __asm ret

FUNCTION _Main_

    // comando de guia
    IF BufferCmp<_Command_,_GuideCommand_> THEN _ShowGuide_
    // comando de busqueda de hijos
    IF BufferCmp<_Command_,_FindChild_> THEN _FindChildAction_
    // comando de escritura rapida de hijos
    IF BufferCmp<_Command_,_WritePci_> THEN _WrtieFirstChild_
    // comando de lectura rapida de hijos
    IF BufferCmp<_Command_,_ReadPci_> THEN _ReadFirstChild_
    // comando de busqueda de hijos de una familia de PCis especifica
    IF BufferCmp<_Command_,_ListPciCmd_> THEN _ListAllPciList_
    // comando de listado sin filtro
    IF BufferCmp<_Command_,_LsPcisCmd_> THEN _LsPcis_

    __asm ret

FUNCTION _ReadFirstChild_
    // encontrarlo
    call_tapot _IPciFindFirstChildOf _PciClassParam_ _PciRegister_ _PciDirection_
    // escribir en el
    call_tapot PciRead _PciDirection_ _PciDataWrite_
    // imprimir el dato
    _CallOut 19 _PciDataWrite_
    __asm ret

FUNCTION _WrtieFirstChild_
    // encontrarlo
    call_tapot _IPciFindFirstChildOf _PciClassParam_ _PciRegister_ _PciDirection_
    // escribir en el
    call_tapot PciWrite _PciDirection_ _PciDataWrite_
    Print "Status:\s0x"
    // obtener el errno de la escritura
    (LET*)1 = **_Errno_
    _CallOut 19 1
    _CallOut 9 0

    __asm ret

FUNCTION _ListAllPciList_

    // obtener la lista
    call_tapot GetPciListIds _PciClassParam_ _PciIdsList_
    // hacer index a 0
    _Index_ = 0
    // listarlos
    call _ListAllPciListLoop_
    // liberar la lista
    FreePool _PciIdsList_
    __asm ret

FUNCTION _ListAllPciListLoop_
    // obtener el item
    call_tapot GetArrayItem _PciIdsList_ _Index_ 3

    // el index
    Print "PciIndex:\s"
    _CallOut 18 3
    Print "\n"
    Print "Direction:\s"

    // obtenerlo
    call_tapot GetArrayItem _PciIdsList_ _Index_ 1
    (LET*)2 = 0
    call_tapot GetPciById 1 2 _PciDirection_

    //
    // imprimir la direccion
    //

    // primera parte
    (LET*)2 = 0
    // extraer el item 0
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // segunda parte
    (LET*)2 = 1
    // extraer el item 1
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // tercera parte
    (LET*)2 = 2
    // extraer el item 2
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // cuarta parte
    (LET*)2 = 3
    // extraer el item 3
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // actualizar la pantalla
    _CallOut 9 0

    // liberar la direccion
    FreePool _PciDirection_

    Print "\n"

    // incrementarlo
    __asm increment _Index_

    // el id
    call_tapot GetArrayLength _PciIdsList_ 2
    // siguiente pci?
    call_tapot CmpAndJump _Index_ 2 _ComparatorType_IfNotGreater_ _ListAllPciListLoop_ 0

    __asm ret


FUNCTION _LsPcis_

    // obtener la lista
    _CallOut 66 _PciIdsList_

    // hacer index a 0
    _Index_ = 0

    // listarlos
    call _ListAllPciListLoop_

    // liberar la lista
    FreePool _PciIdsList_

    __asm ret

FUNCTION _FindChildAction_

    Print "\nPci\sInfo:\n"

    // encontrarlo
    call_tapot _IPciFindFirstChildOf _PciClassParam_ _PciRegister_ _PciDirection_

    // el tipo
    Print "Type\s=\s"
    // imprimirlo
    _CallOut 19 _PciClassParam_
    Print "\n"

    // la direccion
    Print "Direction\s=\s"

    // primera parte
    (LET*)2 = 0
    // extraer el item 0
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // segunda parte
    (LET*)2 = 1
    // extraer el item 1
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // tercera parte
    (LET*)2 = 2
    // extraer el item 2
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // cuarta parte
    (LET*)2 = 3
    // extraer el item 3
    call_tapot GetArrayItem _PciDirection_ 2 3
    // copiar el numero al numero
    (LET*)1 = *3
    // las cifras que tendra el numero hexadecimal
    (LET*)2 = 2
    // hacerlo string
    call_tapot ItoX 1 2 _HexDirection_
    // imprimirlo
    call_tapot PrintPool _HexDirection_
    // liberarlo
    FreePool _HexDirection_

    // actualizar la pantalla
    _CallOut 9 0

    Print "\n"
    __asm ret

FUNCTION _Clear_

    //
    // comandos de escritura/lectura
    //

    FreePool _WritePci_
    FreePool _ReadPci_

    // 
    // comandos de manejo
    //

    FreePool _FindChild_
    FreePool _ListPciCmd_
    FreePool _LsPcisCmd_

    //
    // otros comandos
    //

    FreePool _GuideCommand_
    FreePool _PciDirection_

    __asm ret

FUNCTION _ShowGuide_

    Print "\n"

    //
    // imprimir el autobus, xd
    //

    Print "=================\n"
    Print "|\s[]\s[]\s[]\s[]\s[\s]\n"
    Print "|\sBus\sPCI\sMgr\s|\s|\n"
    Print "-O-------------O|\n\n"

    //
    // imprimir descripcion
    //

    Print "This\sapplication\scan\shelp\syou\sto\sfind\sPCi\sbuses\n"
    Print "and\smake\sanything,\sall\sin\sthe\sShell,\senjoy\s^-^\n\n"

    //
    // imprimir documentacion
    //

    // sintaxis
    Print "syntax:\sPci\s[Command]\s[Class?]\s[Register?]\n"
    Print "\n"

    // comandos
    (LET*)1 = _ConsoleColor_brightgreen_
    call_tapot SetForegroundColor 1
    Print "Commands:\n"
    (LET*)1 = _ConsoleColor_gray_
    call_tapot SetForegroundColor 1
    Print "\s\s--?:\sget\sthis\sguide\n"
    Print "\s\s--fch:\sfind\sa\sPCI\sbus\sand\sprints\sthe\sdirection\n"
    Print "\s\s--wrt:\swrite\sin\sthe\sfirst\sPCi\sdata\n"
    Print "\s\s--red:\sread\sthe\sfirst\sPCi\sdata\n"
    Print "\s\s--lst:\sget\sa\slist\sof\sall\sthe\sPCis\swith\sthat\stype\n"
    Print "\s\s--ls:\slist\sall\sthe\sPCis\swithout\sdiscrimination\s(posibilitie\sexcepcions\sin\sthe\sUEFI\sincluded)\n"
    Print "\n"

    // Clases
    (LET*)1 = _ConsoleColor_brightblue_
    call_tapot SetForegroundColor 1
    Print "Classes:\n"
    (LET*)1 = _ConsoleColor_brightgreen_
    call_tapot SetForegroundColor 1
    Print "\sDisplay:\n"
    (LET*)1 = _ConsoleColor_gray_
    call_tapot SetForegroundColor 1
    Print "\s\s\s03:\sPciClassDisplayCtrl\n"
    Print "\s\s\s00:\sPciClassVga\n"
    (LET*)1 = _ConsoleColor_brightgreen_
    call_tapot SetForegroundColor 1
    Print "\sIsa:\n"
    (LET*)1 = _ConsoleColor_gray_
    call_tapot SetForegroundColor 1
    Print "\s\s\s01:\sPciClassIsa\n"
    Print "\s\s\s80:\sPciClassIsaPositiveDecode\n"
    (LET*)1 = _ConsoleColor_brightgreen_
    call_tapot SetForegroundColor 1
    Print "\sNet:\n"
    (LET*)1 = _ConsoleColor_gray_
    call_tapot SetForegroundColor 1
    Print "\s\s\s02:\sPciClassNetwork\n"
    Print "\s\s\s00:\sPciClassEthernet\n"
    (LET*)1 = _ConsoleColor_brightgreen_
    call_tapot SetForegroundColor 1
    Print "\sOnlyInEmulator:\n"
    (LET*)1 = _ConsoleColor_gray_
    call_tapot SetForegroundColor 1
    Print "\s\s\s15:\sPciHtmlDocMgr\n"
    Print "\s\s\s16:\sPciHtmlDocPusher\n"

    __asm ret